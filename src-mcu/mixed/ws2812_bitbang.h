#include "stm32_at32_compat.h"

/*
ESCs built with the AT32F421 have the WS2812 connected to a GPIO without any timer output capability
which means the pulses have to be generated by software
The timing requirements means this should be done with interrupts disabled
Disabling interrupts would make the RC PWM pulse measurements inaccurate
(the worst case duration of one WS2812 transmission is 45 microseconds)
The solution: only send data to the WS2812 when the falling edge of the RC PWM pulse occurs, or when that timer overflows, from interrupt context
*/

#if defined(MCU_AT421)
#define WS2812_TIMx   TMR16
#ifndef WS2812_PIN
#define WS2812_PIN    GPIO_PINS_7
#endif
#ifndef WS2812_PORT
#define WS2812_PORT   GPIOB
#endif
#else
#define WS2812_TIMx   TIM16
#ifndef WS2812_PIN
#define WS2812_PIN    LL_GPIO_PIN_7
#endif
#ifndef WS2812_PORT
#define WS2812_PORT   GPIOB
#endif
#endif

static uint32_t          rgb_pending = 0;
static volatile bool     new_pending = false;
static volatile uint32_t prev_colour = 0;
volatile bool WS2812_sendOccured = false;

extern void WS2812_startTmr6Anyways(void); // this lives in the rc_gpiotimer.cpp file

void WS2812_waitClkCycles(uint16_t cycles)
{
    LL_TIM_SetCounter(WS2812_TIMx, 0);
    while (LL_TIM_GetCounter(WS2812_TIMx) < cycles) {
    }
}

void WS2812_sendBit(uint8_t bit) // arg is 1 or 0, do not change how this works
{
    WS2812_PORT->BSRR = WS2812_PIN;
    WS2812_waitClkCycles(CPU_FREQUENCY_MHZ >> (2 - bit));
    WS2812_PORT->BRR = WS2812_PIN;
    WS2812_waitClkCycles(CPU_FREQUENCY_MHZ >> (1 + bit));
}

void WS2812_init(void)
{
    LL_TIM_EnableCounter(WS2812_TIMx);
    gpio_mode_QUICK(WS2812_PORT, GPIO_MODE_OUTPUT, GPIO_PULL_NONE, WS2812_PIN);
    WS2812_startTmr6Anyways();
}

void WS2812_setRGB(uint8_t red, uint8_t green, uint8_t blue)
{
    uint8_t* ptr = (uint8_t*)&rgb_pending;
    ptr[1] = red; ptr[2] = green; ptr[0] = blue;
    uint32_t twenty_four_bit_color_number = rgb_pending;
    if (prev_colour != twenty_four_bit_color_number) { // do not waste time if colour didn't change
        new_pending = true;
    }
}

void WS2812_onIrq(void)
{
    if (new_pending == false) {
        return;
    }
    new_pending = false;
    uint32_t twenty_four_bit_color_number = *((uint32_t*)rgb_pending);
    prev_colour = twenty_four_bit_color_number;
    WS2812_TIMx->PSC = 0;
    WS2812_TIMx->EGR |= TIM_EGR_UG;
    for (int i = 0; i < 24 ; i ++) {
        // transfer is MSB first
        WS2812_sendBit((twenty_four_bit_color_number >> (23 - i)) & 1); // arg is 1 or 0, do not change how this works
    }
    //WS2812_PORT->BRR = WS2812_PIN;
    WS2812_TIMx->PSC = CPU_FREQUENCY_MHZ;
    WS2812_TIMx->EGR |= TIM_EGR_UG;
    WS2812_sendOccured = true;
}

void WS2812_task(void)
{
    // do nothing, this is called from main app periodically
    // we want to be sending the bits only when a timer interrupt fires, to avoid jitter in pulse measurements
}
